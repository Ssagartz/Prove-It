'''
specialStatements

Methods for defining axioms and theorems.
'''

from expression.expr import Expression
from proveit._core_.proof import Axiom, Theorem
from proveit._core_.known_truth import KnownTruth
import os

class SpecialStatement:
    definitions = dict()
    lowerCaseNames = set()
    
    def __init__(self, name, expr):
        if not isinstance(expr, Expression):
            raise ValueError("Right hand side of the special statement must be an Expression")
        if name.lower() in SpecialStatement.lowerCaseNames:
            raise SpecialStatementsFailure("Special statement names must be unique regardless of capitalization")
        self.name = name
        self.expr = expr
        SpecialStatement.lowerCaseNames.add(name.lower())
        SpecialStatement.definitions[name] = expr

    def _repr_html_(self):
        return '<strong>' + self.name + '</strong>: ' + self.expr._repr_html_()
    
    @staticmethod
    def finish(package, kind):
        '''
        Finish 'axioms' or 'theorems' for the specified package.
        '''
        from proveit.certify import setAxioms, setTheorems
        # Add the special statements to the certified database
        if kind=='axioms':
            setAxioms(package, SpecialStatement.definitions)
        elif kind=='theorems':            
            setTheorems(package, SpecialStatement.definitions)
        capitalizedKind = kind[0].upper() + kind[1:]
        # make an _axioms_.py or _theorems_.py file for importing axioms/theorems
        # from the certified database.
        output = "import sys\n"
        output += "from proveit._core_.special_statements import %s\n"%capitalizedKind
        output += "sys.modules[__name__] = %s('%s')\n"%(capitalizedKind, package)
        if os.path.isfile('_%s_.py'%kind):
            with open('_%s_.py'%kind, 'r') as f:
                if f.read() != output:
                    raise SpecialStatementsFailure("An existing _%s_.py must be removed before a proper one may be autogenerated"%kind)
        else:        
            with open('_%s_.py'%kind, 'w') as f:
                f.write(output)
        print "%s may be imported from autogenerated _%s_.py"%(capitalizedKind, kind)
                
_excludedLocalVars = None
_specialStatementType = ''

def _beginSpecialStatements(excludedLocalVars, specialStatementType):
    global _excludedLocalVars, _specialStatementType
    _excludedLocalVars = dict(excludedLocalVars)
    _specialStatementType = specialStatementType

def _endSpecialStatements(localVars, specialStatementType, package):
    global _includedVars
    assert specialStatementType == _specialStatementType, 'cannot end ' + specialStatementType + ' without beggining them.'

    # exclude name/values in _excludedLocalVars or names that begin with an underscore
    includedVars = {name:val for name,val in localVars.iteritems() \
                    if _excludedLocalVars.get(name, None) is not val and name[0] != '_'}
    definitions = dict()
    for name, val in includedVars.iteritems():
        '''
        For each non-excluded Expression, state it, mark it as an axiom/theorem, and replace the
        Expression in the localVars with the KnownTruth.
        '''
        expr = val.expr if isinstance(val, KnownTruth) else val
        assert isinstance(expr, Expression), 'Expecting only Expression statements for ' + _specialStatementType + ' variables: ' + name
        if specialStatementType == 'axioms':
            localVars[name] = Axiom(expr, package, name).provenTruth
        if specialStatementType == 'theorems':
            localVars[name] = Theorem(expr, package, name).provenTruth   
        definitions[name] = localVars[name]

    #import time
    for name, val in includedVars.iteritems():
        # Now derive side effects, after all the Axioms/Theorems have been created
        #start_time = time.time()
        localVars[name].deriveSideEffects()
        #print name, (time.time() - start_time), len(KnownTruth.lookup_dict)
    
    return definitions

def beginAxioms(excludedLocalVars):
    _beginSpecialStatements(excludedLocalVars, 'axioms')

def beginTheorems(excludedLocalVars):
    _beginSpecialStatements(excludedLocalVars, 'theorems')

def endAxioms(localVars, package):
    from proveit.certify import setAxioms
    definitions = _endSpecialStatements(localVars, 'axioms', package)
    setAxioms(package, definitions)

def endTheorems(localVars, package):
    from proveit.certify import setTheorems
    definitions = _endSpecialStatements(localVars, 'theorems', package)
    setTheorems(package, definitions)

class Axioms:
    def __init__(self, package):
        self.package = package
        
    def __getattr__(self, name):
        from proveit.certify import getAxiom
        axiom = getAxiom(self.package, name)
        axiom.deriveSideEffects()
        return axiom

class Theorems:
    def __init__(self, package):
        self.package = package
        
    def __getattr__(self, name):
        from proveit.certify import getTheorem
        theorem = getTheorem(self.package, name)
        theorem.deriveSideEffects()
        return theorem

class SpecialStatementsFailure(Exception):
    def __init__(self, message):
        self.message = message
    def __str__(self):
        return self.message